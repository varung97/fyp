\documentclass{article}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{enumerate}
\usepackage{relsize}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{parskip}

\usepackage[
  top    = 2.75cm,
  bottom = 3.00cm,
  left   = 2.50cm,
  right  = 2.50cm
]{geometry}

\algnewcommand\algorithmicinput{\textbf{Input:}}
\algnewcommand\algorithmicoutput{\textbf{Output:}}
\algnewcommand\algorithmicsideeffect{\textbf{Side Effect:}}
\algnewcommand\Input{\item[\algorithmicinput]}
\algnewcommand\Output{\item[\algorithmicoutput]}
\algnewcommand\SideEffect{\item[\algorithmicsideeffect]}
\algnewcommand{\IIf}[1]{\State\algorithmicif\ #1\ \algorithmicthen}
\algnewcommand{\IIEf}[2]{\State\algorithmicif\ #1\ \algorithmicthen\ #2\ \algorithmicelse}
\newcommand{\compatible}{\smile}
\newcommand{\leafset}{\Lambda}

\title{A Faster Construction of Frequency Difference Consensus Trees\\CG4001 Interim Report}
\author{Varun Gupta\\A0147924X}

\newtheorem{incompatibility}{Lemma}
\newtheorem{freqdiffruntimecomponents}[incompatibility]{Corollary}
\newtheorem{assocnode}[incompatibility]{Lemma}
\newtheorem{labelclusterscorrectness}[incompatibility]{Lemma}
\newtheorem{labelclustersruntime}[incompatibility]{Lemma}
\newtheorem{filterclusterssubsetcompatible}[incompatibility]{Lemma}
\newtheorem{computerootsofsubtreescorrectness}[incompatibility]{Lemma}
\newtheorem{findincompatiblecorrectness}[incompatibility]{Lemma}
\newtheorem{incompatibilityrootsofsubtrees}[incompatibility]{Lemma}
\newtheorem{incompatiblecandidates}[incompatibility]{Lemma}
\newtheorem{filterclustersruntime}[incompatibility]{Lemma}
\newtheorem{freqdiffruntime}[incompatibility]{Theorem}

% Improvements:
% 1- Define things before we use - especially true for rootsOfSubtrees. Can put lemmas before Filter_Clusters_Helper also
% 2- Lemmas showing correctness of algorithm - some sort of recursive formulation
% 3- Rework proofs
% 4- Add r_i to rootsOfSubtrees also?
% 5- Will need to process all side trees first
% 6- Insert r_{i-1} first, then iterate upwards then insert parents(roots)
% 7- Don't need all that analysis for deleting kids from roots
% 8- Rename lots of things

% 9. Figure out what's up with the RMQ structure
% 10. Do we really need side effects??
% 11. Diagrams would be helpful!!
% 12. Need a better introduction - what's the motivation behind this problem?

\begin{document}
    \maketitle

    \begin{abstract}
        This report presents a new deterministic algorithm for constructing a frequency difference consensus tree. Given $k$ phylogenetic trees with identical leaf label sets of size $n$, this algorithm constructs the frequency difference tree in $O(kn\,log\,n)$ time, bettering the previously best known time of $O(kn\,log^2n)$.
    \end{abstract}

    \section{Introduction}
    \label{sec:introduction}

    A \textit{taxon} (pl. taxa) is a group of organisms that taxonomists classify as a single unit, such as \textit{homo sapiens}. A \textit{rooted phylogenetic tree} is one that presents the evolutionary relationships between various taxa. Here, the root represents their common ancestor, and children of nodes split each group into smaller ones. A \textit{consensus tree} reconciles multiple phylogenetic trees, summarising the branching information contained in each into a single tree. This report studies a specific type of consensus tree, known as the \textit{frequency difference consensus tree} and arrives at a fast algorithm for constructing this.

    \subsection{Definitions and Notation}
    We define a rooted phylogenetic tree to be a rooted, leaf-labelled tree where every internal node has 2 or more children and every leaf has a different label. Henceforth, we will simply refer to these as trees. For any tree $T$, let $V(T)$ be the vertex set of $T$ and $\leafset(T)$ be the leaf set of $T$. Non-empty subsets of $\leafset(T)$ are called \textit{clusters}. Clusters with cardinality $1$ or $|\leafset(T)|$ are \textit{trivial clusters}. For any $u \in V(T)$, $T[u]$ is the subtree of $T$ rooted at $u$. Then $\leafset(T[u])$ is the cluster \textit{associated} with $u$. The \textit{cluster collection} of $T$, $\mathcal{C}(T)$ is the set $\bigcup_{u \in V(T)} {\leafset(T[u])}$, i.e. a set containing all the clusters in $T$. Any cluster $C \subseteq \leafset(T)$ \textit{occurs} in $T$ iff $C \in \mathcal{C(T)}$. Also define, for any tree $T$, for any cluster $C \subseteq \leafset(T)$, $lca^T(C)$ to be the least common ancestor of $C$ in $T$.

    Any two clusters $C_1, C_2 \in \mathcal{C}(T)$ are said to be \textit{compatible}, denoted as $C_1 \compatible C_2$, iff $C_1 \subseteq C_2$ or $C_2 \subseteq C_1$ or $C_1 \cap C_2 = \emptyset$. If $C_1$ and $C_2$ satisfy none of the preceding properties, then they are said to be \textit{incompatible}, denoted as $C_1 \not\compatible C_2$. Similarly given trees $T_1$ and $T_2$ with the same leaf sets, and nodes $u \in V(T_1)$, $v \in V(T_2)$, we say $u$ is compatible with $v$ if the clusters associated with $u$ and $v$ are compatible. We now extend the notion of compatibility to trees. A cluster $C \subseteq \leafset(T)$ is \textit{compatible} with $T$ iff for every $u \in V(T)$, $C \compatible \leafset(T[u])$. Further, two trees $T_1$ and $T_2$ satisfying $\leafset(T_1) = \leafset(T_2)$ are \textit{compatible} iff for every $u \in V(T_1)$, $\leafset(T_1[u]) \compatible T_2$, i.e. if every cluster in $T_1$ is compatible with $T_2$. Observe that this also means that every cluster in $T_2$ is compatible with $T_1$.

    A \textit{frequency difference consensus tree} can then be defined as thus. Let $\mathcal{S}$ be a set of $k$ trees with identical leafs labels, i.e. $\mathcal{S} = \{T_1, T_2, ..., T_k\}$, where $\leafset(T_1) = \leafset(T_2) = ... = \leafset(T_k) = L$. For any cluster $C \subseteq L$, let $K_C = \{T : T \in \mathcal{S} \text{ and } C \in \mathcal{C}(T)\}$ be the set of trees in $\mathcal{S}$ which $C$ occurs in. Let $T_{FD}$ be the frequency difference consensus tree of $\mathcal{S}$, with $\mathcal{C}(T_{FD}) = \{C : C \subseteq L \text{ and } |K_C| > max(\{|K_{C_1}| : C_1 \subseteq L \text{ and } C \not\compatible C_1\})\}$. Thus $T_{FD}$ contains all clusters that occur more frequently than any cluster that they are incompatible with. By Proposition $3$ in \cite{steel2014axiomatic}, this tree always exists and is unique for a given $\mathcal{S}$. [Need example]

    Henceforth, $\mathcal{S}$ is taken to be the input set of trees with identical leaf labels. This set of leaf labels is denoted by $L$. Let $|\mathcal{S}| = k$ and $|L| = n$.

    \subsection{Previous Work}
    Jansson et al. \cite{jansson2018algorithms} gave a deterministic $min\{O(kn^2), O(kn(k + log^2 n))\}$ algorithm for constructing the frequency difference tree. Gawrychowski et al. \cite{gawrychowski2017faster} improved this to a deterministic $O(kn\,log^2n)$ algorithm.

    \subsection{Organisation of the Article and New Results}
    Section~\ref{sec:preliminaries} contains some results from previous works that are utilised later. Section~\ref{sec:freqdiffconstruction} presents a new deterministic algorithm for constructing the frequency difference tree that runs in $O(kn\,log\,n)$ time. Section~\ref{sec:futurework} lays out plans for future work.

    \section{Preliminaries}
    \label{sec:preliminaries}

    \subsection{The \textit{delete} operation}
    As described in \cite{jansson2018algorithms}, the \textit{delete} operation deletes a cluster from a tree. To do so, we specify some internal node $u$ in a tree $T$, such that we wish $\leafset(T[u])$ to be deleted. Then the \textit{delete} operation makes $parent(u)$ the parent of all nodes in $children(u)$ and removes $u$, along with any associated edges from $T$. This has the effect of removing only $\leafset(T[u])$ from $T$, without affecting any other cluster.

    \subsection{Characterising incompatibility}
    We restate Lemma 6 of \cite{jansson2018algorithms} here since it is crucial in the development of an algorithm discussed below:
    \newline

    \begin{incompatibility}
        \label{lem:incompatibility}

        Given a tree $T$ and a cluster $C \subseteq \leafset(T)$, let $r_C = lca^T(C)$. Then for any $u \in V(T)$, $C \not\compatible \leafset(T[u])$ iff $u$ lies on the path between $r_C$ and some $x \in C$ and $\leafset(T[u]) \not\subseteq C$.
    \end{incompatibility}

    \subsection{\texttt{Frequency\_Difference} algorithm}
    The algorithm \texttt{Frequency\_Difference} is laid out in \cite{jansson2018algorithms}. Before describing this, we first define the weight of a node $u$ to be the number of trees in $\mathcal{S}$ that the cluster associated with $u$ occurs in. Formally, for any tree $T \in \mathcal{S}$ and any node $u \in V(T)$, let $C = \leafset(T[u])$, then $weight(u) = w(u) = |K_C|$ and $w(C) = w(u)$. Further, define a procedure \texttt{Filter\_Clusters} which takes in trees $T_A$ and $T_B$, with $\leafset(T_A) = \leafset(T_B) = L$ and $w(u)$ computed for any $u \in V(T_A) \cup V(T_B)$. It returns a tree $T$ which contains all clusters $C$ in $T_A$ for which $w(C) > $ weight of all clusters in $T_B$ that it is incompatible with. Formally, \texttt{Filter\_Clusters}$(T_A, T_B) = T$ where $\mathcal{C}(T) = \{C : C \in \mathcal{C}(T_A) \text{ and } w(C) > max(\{w(C_1) : C_1 \in \mathcal{C}(T_B) \text{ and } C_1 \not\compatible C\})\}$ and $\leafset(T) = L$.

    Then the algorithm \texttt{Frequency\_Difference} runs in two parts. First, for any tree $T \in \mathcal{S}$ and any node $u \in V(T)$, it computes $w(u)$. We call this the \textit{labelling} step. In the second part, it utilises \texttt{Filter\_Clusters} and \texttt{Merge\_Trees} (from \cite{jansson2016improved}) to compute the frequency difference consensus tree. Theorem 3 of \cite{jansson2018algorithms} gives the following corollary:

    \begin{freqdiffruntimecomponents}
        \label{cor:freqdiffruntimecomponents}

        The total runtime of \texttt{Frequency\_Difference} is given by $O(g(n, k) + k \cdot f(n))$ where $g(n, k)$ is the time taken by the labelling step and $f(n)$ is the runtime of \texttt{Filter\_Clusters}.
    \end{freqdiffruntimecomponents}

    Jansson et al. \cite{jansson2018algorithms} gave a $min(\{O(kn^2), O(k^2n)\})$ solution to the labelling step and an $O(n\,log^2n)$ solution to \texttt{Filter\_Clusters}, giving an overall runtime of $min(\{O(kn^2), O(kn(k + log^2n))\})$. Gawrychowski et al. \cite{gawrychowski2017faster} improved the runtime of the labelling step to $O(kn\,log^2n)$, thus reducing the overall runtime to $O(kn\,log^2n)$.

    \section{Constructing the Frequency Difference Consensus Tree}
    \label{sec:freqdiffconstruction}

    We present an $O(kn\,log\,n)$ solution for the labelling step in section 3.1 and an $O(n\,log\,n)$ solution for \texttt{Filter\_Clusters} in section 3.2. Taken together with Corollary 2, this allows us to solve \texttt{Frequency\_Difference} in $O(kn\,log\,n)$ time.

    \subsection{Labelling}
    As in \cite{gawrychowski2017faster}, we divide the labelling step into two parts. First, we give a label to every node $u$, where $u \in V(T)$ for some $T \in \mathcal{S}$, denoted by $id(u)$. The labels obey the restrictions that $id(u) \in [1, kn]$ and for some $u' \in T'$, $T' \in \mathcal{S}$, $id(u) = id(u')$ iff $\leafset(T[u]) = \leafset(T'[u'])$. That is, two nodes will have the same label iff they are associated with the same cluster. Second, we counting sort these labels, allowing us to count how many nodes exist with a certain label, giving us the frequency of those nodes in $\mathcal{S}$.

    First, for some tree $T$ and some cluster $C \subseteq \leafset(T)$ define $T|C$, read as ``$T$ restricted to $C$'', as the tree $T'$ with $V(T') = \{lca^T(u, v) : u, v \in C\}$ which obeys $lca^T(C') = lca^{T'}(C')$ for all nonempty $C' \subseteq C$. Intuitively, $T'$ has the leaf set $C$ and consists of all nodes in $T$ that are $lca$'s of the leafs in $C$, with these nodes connected such that they have the same ancestor/descendant relationships as they had in $T$. Further, for any node $u$ in $T$, define the node that $u$ is associated with when $T$ is restricted to $C$ to be the descendant of $u$ with least depth that is in $T|C$, denoted as $assoc^{C}(u)$.

    The algorithm \texttt{Label\_Clusters} is laid out below.

    \begin{algorithm}
        \caption{Label\_Clusters}
        \label{alg:labelclusters}

        \begin{algorithmic}[1]
            \Input A set $\mathcal{S}$ of trees $\{T_1, T_2, ..., T_k\}$ where $\leafset(T_1) = \leafset(T_2) = ... = \leafset(T_k) = L$

            \Output Every node in the trees in $\mathcal{S}$ is labelled such that nodes associated with the same cluster have the same labels and for any $u$, $id(u) \in [1, k |L|]$

            \State Partition $L$ into $L'$ and $L''$ such that $|L'| = |L''|$.

            \State For all $i \in [1,k]$, let $T'_i = T_i|L'$ and $T''_i = T_i|L''$.

            \State \texttt{Label\_Clusters}$(T'_1, T'_2, ..., T'_k)$.

            \State \texttt{Label\_Clusters}$(T''_1, T''_2, ..., T''_k)$.

            \State For every tree $T \in \mathcal{S}$, for every node $u \in T$, represent $u$ by the pair $(id(assoc^{L'}(u)), id(assoc^{L''}(u)))$.

            \State Radix sort all pairs obtained. Assign each set of duplicates found thus a rank.

            \State For every tree $T \in \mathcal{S}$, for every node $u \in T$, set $id(u) = $ rank of the pair $(id(assoc^{L'}(u)), id(assoc^{L''}(u)))$.
        \end{algorithmic}
    \end{algorithm}

    \bigskip
    \begin{assocnode}
        \label{lem:assocnode}

        For any tree $T$, for any node $u \in V(T)$ and any cluster $C \subseteq \leafset(T)$, $\leafset(T|C[assoc^C(u)]) = \leafset(T[u])\, \cap\, C$.

        \begin{proof}
            First note that for any node $v \in V(T|C)$, $\leafset(T|C[v]) = \leafset(T[v])\, \cap\, C$ due to the way $T|C$ is constructed. Also, $\leafset(T[assoc^C(u)]) \subseteq \leafset(T[u])$ since $assoc^C(u)$ is a descendant of $u$. Thus $\leafset(T[assoc^C(u)])\, \cap\, C \subseteq \leafset(T[u])\, \cap\, C$ and so $\leafset(T|C[assoc^C(u)]) \subseteq \leafset(T[u])\, \cap\, C$.

            This implies that if $\leafset(T|C[assoc^C(u)]) \neq \leafset(T[u])\, \cap\, C$ then there is some leaf $x$ such that $x \in \leafset(T[u])\, \cap\, C$ and $x \not\in \leafset(T|C[assoc^C(u)])$. Then let $v = lca^T(C \cup x)$. Observe that $v$ is proper ancestor of $u$, since $\leafset(T[u]) = C \subseteq C \cup x = \leafset(T[v])$ and $\leafset(T[u]) \neq \leafset(T[v])$. Also, since $v = lca^T(C \cup x)$ and $C \cup x \subseteq \leafset(T[u])$, $v$ is a descendant of $u$. Finally, $v \in V(T|C)$. But then an ancestor of $v$ would be $assoc^C(u)$, and not the node that was initially obtained.
        \end{proof}
    \end{assocnode}

    \medskip
    \begin{labelclusterscorrectness}
        \label{lem:labelclusterscorrectness}

        After running \texttt{Label\_Clusters}$(\mathcal{S})$, for any trees $T_i, T_j \in \mathcal{S}$, for any nodes $u \in V(T_i), v \in V(T_j)$, $id(u) = id(v)$ iff $\leafset(T_i[u]) = \leafset(T_j[v])$.

        \begin{proof}
            $id(u) = id(v)$ iff $id(assoc^{L'}(u)) = id(assoc^{L'}(v))$ and $id(assoc^{L''}(u)) = id(assoc^{L''}(v))$. Inductively, the first part is true iff $\leafset(T_i|L'[assoc^{L'}(u)]) = \leafset(T_j|L'[assoc^{L'}(v)])$. By Lemma~\ref{lem:assocnode}, $\leafset(T_i[u])\, \cap\, L' = \leafset(T_j[v])\, \cap\, L'$. Symmetrically, the second part is true iff $\leafset(T_i[u])\, \cap\, L'' = \leafset(T_j[v])\, \cap\, L''$. Since $L'$ and $L''$ partition $L$, both parts are true iff $\leafset(T_i[u]) = \leafset(T_j[v])$.
        \end{proof}
    \end{labelclusterscorrectness}

    \medskip
    \begin{labelclustersruntime}
        \label{lem:labelclustersruntime}

        The algorithm \texttt{Label\_Clusters}$(\mathcal{S})$ runs in $O(kn\,log\,n)$ time.

        \begin{proof}
            Let $T(m)$ be the runtime of \texttt{Label\_Clusters}$(\mathcal{T})$, where $m =$ size of leaf set of each tree in $\mathcal{T}$. By Lemma 5.2 of \cite{farach1995fast}, construction of $T'_i$ and $T''_i$ takes $O(m)$ time for each $T_i \in \mathcal{T}$, taking total $O(km)$ time over all the trees. For each $T_i \in \mathcal{T}$, $|V(T_i)| = O(m)$. Computing $assoc^{L'}(u)$ and $assoc^{L''}(u)$ for each node $u$ in some tree $T_i \in \mathcal{T}$ can be done by a bottom up traversal of $T_i$ along with $T'_i$ and $T''_i$, taking $O(km)$ time total. Also observe that the number of pairs obtained is $O(km)$. Further, each of the values in the pair are in the range [1, km/2]. Thus radix sorting these pairs and assigning labels back to the nodes takes $O(km)$ time. So $T(m) = 2T(m/2) + O(km)$, giving $T(n) = kn\,log\,n$.
        \end{proof}
    \end{labelclustersruntime}

    \subsection{\texttt{Filter\_Clusters}}

    Recall that \texttt{Filter\_Clusters}$(T_A, T_B) = T$ where $\mathcal{C}(T) = \{C : C \in \mathcal{C}(T_A) \text{ and } w(C) > max(\{w(C_1) : C_1 \in \mathcal{C}(T_B) \text{ and } C_1 \not\compatible C\})\}$ and $\leafset(T) = L$. Thus, for any node $u \in V(T_A)$, we would like to find the set of nodes in $T_B$ that are incompatible with $u$, so that we can find the maximum weight of these.

    Before describing how this is done, we prove some important lemmas.
    \newline

    \begin{filterclusterssubsetcompatible}
        \label{lem:filterclusterssubsetcompatible}

        Let nodes $u \in V(T_A)$, $v \in V(T_B)$ such that $\leafset(T_B[v]) \subseteq \leafset(T_A[u])$. Then for any $u' \in V(T_A) - V(T_A[u])$, and any $v' \in V(T_B[v])$, $\leafset(T_A[u']) \compatible \leafset(T_B[v'])$.

        \begin{proof}
            Note that $\leafset(T_B[v']) \subseteq \leafset(T_B[v])$ since $v'$ is in the subtree rooted at $v$. There are two cases for $u'$. \textit{Case 1}: $u'$ is an ancestor of $u$. Then $\leafset(T_A[u]) \subseteq \leafset(T_A[u'])$. Thus $\leafset(T_B[v']) \subseteq \leafset(T_A[u'])$, and so $\leafset(T_B[v']) \compatible \leafset(T_A[u'])$. \textit{Case 2}: $u'$ is not an ancestor of $u$. Since $u'$ is also not a descendant of $u$, $\leafset(T_A[u']) \cap \leafset(T_A[u]) = \emptyset$. Thus $\leafset(T_A[u']) \cap \leafset(T_B[v']) = \emptyset$ and so $\leafset(T_B[v']) \compatible \leafset(T_A[u'])$.
        \end{proof}
    \end{filterclusterssubsetcompatible}

    This lemma says that if the cluster associated with some node $v \in V(T_B)$ is a subset of the cluster associated with some node $u \in V(T_A)$, then $v$ is the root of a subtree of $T_B$ that is compatible with every node in $V(T_A) - V(T_A[u])$. The upshot of this is that if once we process $u$ we are known to have also processed the entirety of $T_A[u]$, then for the remaining nodes, no node in $V(T_B[v])$ needs to be considered for incompatibility again.

    For any cluster $C \subseteq L$, define any node $r \in V(T_B)$ to be the root of a \textit{maximal subtree compatible with $C$} if it satisfies the following property: $\leafset(T_B[r]) \subseteq C$ and there is no proper ancestor $r'$ of $r$ such that $\leafset(T_B[r']) \subseteq C$. We denote this as $rootsOfSubtrees(C)$.

    We now prove a stronger version of Lemma~\ref{lem:incompatibility} that takes $rootsOfSubtrees$ into account to compute the set $incompatible(u) = \{v : v \in V(T_B) \text{ and } \leafset(T_B[v]) \not\compatible \leafset(T_A[u])\}$ for any $u \in V(T_A)$.

    \begin{incompatibilityrootsofsubtrees}
        \label{lem:incompatibilityrootsofsubtrees}

        Let $path(v, w)$ for any nodes $v, w \in T_B$ be a set containing all nodes that are ancestors of $v$ and proper descendants of $w$. For any node $u \in V(T_A)$, define $l_u = lca^{T_B}(\leafset(T_A[u]))$. Then for any $u \in V(T_A)$, $v \in incompatible(u)$ iff $v$ is a proper descendant of $l_u$ and for some $r \in rootsOfSubtrees(u)$, $v$ is a proper ancestor of $r$. i.e. $incompatible(u) = \bigcup_{r \in rootsOfSubtrees(u)} path(parent^{T_B}(r), l_u)$.

        \begin{proof}
            \textit{Forward direction}: Given some $v \in V(T_B)$ such that $\leafset(T_B[v]) \not\compatible \leafset(T_A[u])$, $v$ must be a proper descendant of $l_u$ by Lemma~\ref{lem:incompatibility}. Further, for some $x \in \leafset(T_A[u])$, $v$ is a proper ancestor of $x$ by Lemma~\ref{lem:incompatibility}. Then there must be $r \in rootsOfSubtrees(u)$, $r$ is an ancestor of $x$. $v \not\in V(T_B[r])$, otherwise $\leafset(T_B[v]) \subseteq \leafset(T_A[u])$. Thus $v$ is a proper ancestor of $r$.

            \textit{Backward direction}: Given some $v \in V(T_B)$ such that $v$ is a proper descendant of $l_u$ and for some $r \in rootsOfSubtrees(u)$, $v$ is a proper ancestor of $r$. Since $v$ is a proper descendant of $l_u$, $\leafset(T_A[u]) \not\subseteq \leafset(T_B[v])$. Since $v$ is a proper ancestor of $r$, $\leafset(T_B[r]) \subset \leafset(T_B[v])$, so $\leafset(T_B[v]) \cap \leafset(T_A[u]) \neq \emptyset$. Finally, $\leafset(T_B[v]) \not\subseteq \leafset(T_A[u])$, otherwise $r \not\in rootsOfSubtrees(u)$.
        \end{proof}
    \end{incompatibilityrootsofsubtrees}

    Thus we would be interested in determining $rootsOfSubtrees(\leafset(T_A[u]))$ for any node $u \in V(T_A)$. To compute this, we define a property $counter(v)$ for every $v \in V(T_B)$ (as in \cite{jansson2018algorithms}). $counter(v) =$ number of leaves in $T_B[v]$ that belong to some set under consideration. If we take this set to be $\leafset(T_A[u])$, then $counter(v) = |\leafset(T_B[v]) \cap \leafset(T_A[u])|$. When $counter(v) = |\leafset(T_B[v])|$ then $\leafset(T_B[v]) \subseteq \leafset(T_A[u])$. So our problem is reduced to computing $counter(v)$ correctly. The process we follows is presented in Algorithm~\ref{alg:computerootsofsubtrees}. This algorithm starts off by recursively computing $rootsOfSubtrees(\leafset(T_A[c]))$ for each $c \in children(u)$, and putting these sets together into a set called $lowerBoundary$. Then we iterate upwards from each node in $lowerBoundary$, updating $counter$ and $rootsOfSubtrees$ as shown. We show the correctness of this algorithm below.

    \begin{algorithm}
        \caption{Compute\_Roots\_Of\_Subtrees}
        \label{alg:computerootsofsubtrees}

        \begin{algorithmic}[1]
            \Input Node $u \in V(T_A)$ and $T_B$ with $\leafset(T_A) = \leafset(T_B) = L$.

            \Output $rootsOfSubtrees(\leafset(T_A[u]))$

            \State $lowerBoundary := \bigcup_{c \in children(u)} rootsOfSubtrees(\leafset(T_A[c]))$

            \State $roots := \{\}$

            \ForAll{$v \in lowerBoundary$}
                \While{$counter(v) = |\leafset(T_B[v])|$}
                    \State $counter(parent^{T_B}(v)) := counter(parent^{T_B}(v)) + |\leafset(T_B[v])|$

                    \State $roots := (roots \cup {v}) - children(v)$

                    \State $v := parent^{T_B}(v)$
                \EndWhile
            \EndFor

            \State \Return $roots$
        \end{algorithmic}
    \end{algorithm}

    \bigskip
    \begin{computerootsofsubtreescorrectness}
        \label{lem:computerootsofsubtreescorrectness}

        The algorithm \texttt{Compute\_Roots\_Of\_Subtrees}$(u, T_B)$ outputs $rootsOfSubtrees(\leafset(T_A[u]))$.

        \begin{proof}
            We prove a loop invariant. Let the nodes in $lowerBoundary$ be numbered $1$ to $\beta = |lowerBoundary|$ in the order that they will be iterated over, i.e. $lowerBoundary = \{r_1, r_2, ..., r_{\beta}\}$. For any $i$, $1 \leq i \leq \beta$, let $D_i = \bigcup_{j = 1}^{i} \leafset(T_B[r_j])$. Then we claim that after the loop in \texttt{Compute\_Roots\_Of\_Subtrees} is finished processing $r_i \in lowerBoundary$, the set $roots = rootsOfSubtrees(D_i)$. Additionally, for any node $v \in \bigcup_{r \in roots} parent^{T_B}(r)$, $counter(v) = \sum_{c \in children(v) \cap roots} |\leafset(T_B[c])|$.

            We consider the loop for $r_i \in lowerBoundary$, $i > 1$. For any node $r \in rootsOfSubtrees(D_i) - rootsOfSubtrees(D_{i-1})$, $\leafset(T_B[r]) \subseteq D_i$ and $\leafset(T_B[r]) \not\subseteq D_{i-1}$. Thus there is some $x \in \leafset(T_B[r])$ such that $x \in D_i - D_{i-1}$. Note that $r$ is an ancestor of $x$. $r_i$ is also an ancestor of $x$ since $x \in D_i - D_{i-1} = \leafset(T_B[r_i])$. But $\leafset(T_B[r_i]) \subseteq D_i$. Then $r$ must be an ancestor of $r_i$ since $r \in rootsOfSubtrees(D_i)$. Thus any new node $r$ that needs to be added to $roots$ is an ancestor of $r_i$.

            We now prove a loop invariant for the inner loop. We claim that when the inner loop is done processing some $v \in V(T_B)$, it is true that $\leafset(T_B[v]) \subseteq D_i$, the parent counter invariant is satisified and no proper descendant of $v$ is in $roots$. To see this is true, consider the processing of some $v \in V(T_B)$. Since $v$ passed the while loop check, $counter(v) = |\leafset(T_B[v])|$. Also, by the parent counter invariant, $counter(v) = \sum_{c \in children(v) \cap roots} |\leafset(T_B[c])|$. Then it must be true that $\leafset(T_B[v]) \subseteq D_i$ and for all $c \in children(v)$, $c \in roots$. So $counter(parent^{T_B}(v)) = \sum_{c \in children(v) \cap roots} |\leafset(T_B[c])|$ by the parent counter invariant. Also, $v$ cannot have already been in $roots$ since $D_i - D{i-1} \subseteq \leafset(T_B[v])$. Finally, it is true that for any $c \in children(parent^{T_B}(v))$, $c \neq v$, $\leafset(T_B[c]) \cap \leafset(T_B[v]) = \emptyset$. Thus the updated counter for $parent^{T_B}(v) = counter(parent^{T_B}(v)) + |\leafset(T_B[v])|$, since $v$ is being added to $roots$. Notice that this is the only node in $T_B$ whose counter needs to be updated in this step, hence showing that the algorithm maintains the parent counter invariant. We can also apply the outer and inner loop invariants to see that for all $c \in children(v)$, no proper descendant of $c$ is in $roots$. Then we add $v$ to $roots$ and remove all children of $v$ from $roots$, maintaining the invariant that no proper descendant of $v$ is in $roots$.

            Applying the inner loop invariant, we see that when the inner loop terminates, the parent counter invariant is maintained. Further we note that since it terminated, the current $v$ is such that $counter(v) \neq |\leafset(T_B[v])|$. Then if for all $c \in children(v)$, $c \in roots$, in fact $counter(v) = |\leafset(T_B[v])|$. Thus there is some $c \in children(v)$, $c \not\in roots$. $c$ cannot be on the path from $r_i$ to $v$, otherwise by our algorithm it would have been added to $roots$ in the last iteration. Thus we can apply our outer loop invariant to $c$ to see that $\leafset(T_B[c]) \not\subseteq D_i$. Hence it must be true that $\leafset(T_B[v]) \not\subseteq D_i$, so $v \not\in rootsOfSubtrees(D_i)$. Further no ancestor of $v$ is in $rootsOfSubtrees(D_i)$ either. Thus the node that was added to $roots$ in the last iteration of the inner loop is the root of a maximal subtree compatible with $D_i$ and so $roots = rootsOfSubtrees(D_i)$.

            Applying the outer loop invariant, when this loop finishes, $roots = rootsOfSubtrees(D_{\beta}) = rootsOfSubtrees(\leafset(T_A[u]))$.
        \end{proof}
    \end{computerootsofsubtreescorrectness}

    Finally, we show how, given an internal node $u \in V(T_A)$ and node $c_1 \in children(u)$, we can build $incompatible(u)$ using $incompatible(c_1)$. To be able to do this, we present Lemma~\ref{lem:incompatiblecandidates}, showing how we can build up a set of nodes that are candidates for being incompatible with $u$.
    \newline

    \begin{incompatiblecandidates}
        \label{lem:incompatiblecandidates}

        Given an internal node $u \in V(T_A)$ and node $c_1 \in children(u)$, let the set $lowerBoundary(u, c_1) = \bigcup_{c \in children(u) - \{c_1\}} rootsOfSubtrees(\leafset(T_A[c]))$. Arbitrarily fix some ordering for the nodes in $lowerBoundary$, such that $lowerBoundary = \{r_1, r_2, ..., r_{\beta}\}$.

        We define $D_0 = \leafset(T_B[c_1])$ for convenience. Further define $candidates_0 = incompatible(c_1) \cup path(l_{c_1}, l_u)$ if $l_{c_1} \not\in rootsOfSubtrees(\leafset(T_B[c_1]))$, otherwise $candidates_0 = incompatible(c_1) \cup path(parent^{T_B}(l_{c_1}), l_u)$.

        For any $i$, $1 \leq i \leq \beta$, let $D_i = D_0 \cup \bigcup_{j = 1}^{i} \leafset(T_B[r_j])$. For any $i$, $0 \leq i \leq \beta$, let $candidates_i = \bigcup_{s \in rootsOfSubtrees(D_i)} path(parent^{T_B}(s), l_u)$. Clearly, there is some $r \in rootsOfSubtrees(D_i)$, such that $\leafset(T_B[r_i]) \subseteq \leafset(T_B[r])$. Then $candidates_i = (candidates_{i-1} - V(T_B[r])) \cup path(parent^{T_B}(r), l_u)$.

        \begin{proof}
            First, we show that $candidates_0 = \bigcup_{s \in rootsOfSubtrees(D_0)} path(parent^{T_B}(s), l_u)$. This holds because $incompatible(c_1) = \bigcup_{s \in rootsOfSubtrees(D_0)} path(parent^{T_B}(s), l_{c_1})$ [By Lemma~\ref{lem:incompatibilityrootsofsubtrees}], to which we add $path(parent^{T_B}(l_{c_1}), l_u)$ and $l_{c_1}$ if $l_{c_1} \not\in rootsOfSubtrees(D_0)$.

            We show that $rootsOfSubtrees(D_i) \cap rootsOfSubtrees(D_{i-1}) = rootsOfSubtrees(D_{i-1}) - V(T_B[r])$.

            Take some $v \in rootsOfSubtrees(D_i) \cap rootsOfSubtrees(D_{i-1})$. Note that $v \neq r$ since $\leafset(T_B[v]) \subseteq D_{i-1}$, $D_{i-1} \cap \leafset(T_B[r_i]) = \emptyset$ and $\leafset(T_B[r_i]) \subseteq \leafset(T_B[r])$. Also, $v$ is not a proper descendant of $r$, otherwise both $v$ and $r$ could not belong to $rootsOfSubtrees(D_i)$. Thus $v \in rootsOfSubtrees(D_{i-1}) - V(T_B[r])$. Now take some $v \in rootsOfSubtrees(D_{i-1}) - V(T_B[r])$. Since $\leafset(T_B[v]) \subseteq D_{i-1} \subseteq D_i$, if $v \not\in rootsOfSubtrees(D_i)$ then there is some proper ancestor $v'$ of $v$ such that $\leafset(T_B[v']) \subseteq D_i$. If $\leafset(T_B[v']) \cap \leafset(T_B[r_i]) = \emptyset$, then $\leafset(T_B[v']) \subseteq D_{i-1}$, but then $v \not\in rootsOfSubtrees(D_{i-1})$. So $\leafset(T_B[v']) \cap \leafset(T_B[r_i]) \neq \emptyset$. Since $\leafset(T_B[r_i]) \subseteq \leafset(T_B[r])$, $v'$ is either a descendant of $r$ (which is not possible, otherwise $v \in V(T_B[r])$) or $v'$ is a proper ancestor of $r$ (which is not possible, otherwise $r \not\in rootsOfSubtrees(D_i)$). Thus $v \in rootsOfSubtrees(D_i)$.

            Now we show that $rootsOfSubtrees(D_i) - rootsOfSubtrees(D_{i-1}) = \{r\}$. Let $v$ be a node such that $v \in rootsOfSubtrees(D_i) - rootsOfSubtrees(D_{i-1})$ and $v \neq r$. Then $\leafset(T_B[v]) \subseteq D_i$ and $\leafset(T_B[v]) \not\subseteq D_{i-1}$. Thus there is some $x \in \leafset(T_B[r_i])$ such that $x \in \leafset(T_B[v])$. Since $\leafset(T_B[r_i]) \subseteq \leafset(T_B[r])$, $v$ is either a proper descendant or proper ancestor of $r$. But then both $v$ and $r$ cannot be in $rootsOfSubtrees(D_i)$. Thus there is no such node $v$.

            Thus the sets $rootsOfSubtrees(D_{i-1}) - V(T_B[r])$ and $\{r\}$ partition $rootsOfSubtrees{D_i}$.

            Take some node $v \in candidates_i$. If $v$ is a proper ancestor of $r$, then clearly $v \in path(parent^{T_B}(r), l_u)$. Otherwise $v$ is a proper ancestor of some node $r' \in rootsOfSubtrees(D_i)$, $r' \neq r$. Then $r' \in rootsOfSubtrees(D_{i-1}) - V(T_B[r])$, so $r' \in rootsOfSubtrees(D_{i-1})$. Thus $v \in candidates_{i-1}$. Since $v \not\in V(T_B[r])$ (otherwise $r'$ would be a proper descendant of $r$), $v \in candidates_{i-1} - V(T_B[r])$.

            Now take some node $v \in (candidates_{i-1} - V(T_B[r])) \cup path(parent^{T_B}(r), l_u)$. If $v \in path(parent^{T_B}(r), l_u)$, then clearly $v \in candidates_i$. Otherwise, $v \in candidates_{i-1} - V(T_B[r]) - path(parent^{T_B}(r), l_u)$. Then there is some node $r' \in rootsOfSubtrees(D_{i-1})$ such that $v$ is a proper ancestor of $r'$. If $r' \in V(T_B[r])$ then $v \in V(T_B[r]) \cup path(parent^{T_B}(r), l_u)$. Thus $r' \not\in V(T_B[r])$. This means $r' \in rootsOfSubtrees(D_i) \cap rootsOfSubtrees(D_{i-1})$, so $r' \in rootsOfSubtrees(D_i)$, hence $v \in candidates_i$.

            To complete the recurrence for $candidates_i$, let $candidates_0 = incompatible(c_1)$
        \end{proof}
    \end{incompatiblecandidates}

    Note that $candidates_{\beta} = \bigcup_{s \in rootsOfSubtrees(D_i)} path(parent^{T_B}(s), l_u) = \bigcup_{s \in rootsOfSubtrees(\leafset(T_B[u]))} path(parent^{T_B}(s), l_u) = incompatible(u)$. With these results in hand, we present Algorithm~\ref{alg:findincompatible}, to find $incompatible(u)$. Note that the input tree $T_B$ is required to satisfy the parent counter invariant for $\leafset(T_B[c_1])$.

    \begin{algorithm}
        \caption{Find\_Incompatible}
        \label{alg:findincompatible}

        \begin{algorithmic}[1]
            \Input Internal node $u \in V(T_A)$, node $c_1 \in children(u)$ and tree $T_B$ with $\leafset(T_A) = \leafset(T_B) = L$.

            \Output $incompatible(u)$

            \State $candidates := incompatible(c_1)$

            \State $roots := rootsOfSubtrees(\leafset(T_A[c_1]))$

            \State $lowerBoundary := \bigcup_{c \in children(u) - \{c_1\}} rootsOfSubtrees(\leafset(T_A[c]))$

            \If{$\leafset(T_B[l_{c_1}]) \in roots$}
                \State $candidates := candidates \cup path(parent^{T_B}(l_{c_1}), l_u)$
            \Else
                \State $candidates := candidates \cup path(l_{c_1}, l_u)$
            \EndIf

            \ForAll{$v \in lowerBoundary$}
                \While{$counter(v) = |\leafset(T_B[v])|$}
                    \State $counter(parent^{T_B}(v)) := counter(parent^{T_B}(v)) + |\leafset(T_B[v])|$

                    \State $roots := (roots \cup {v}) - children(v)$

                    \IIf{$v \in candidates$}
                        {$candidates := candidates - \{v\}$}

                    \State $v := parent^{T_B}(v)$
                \EndWhile

                \IIf{$v \not\in candidates$}
                    $candidates := candidates \cup path(v, l_u)$
            \EndFor

            \State \Return $candidates$
        \end{algorithmic}
    \end{algorithm}

    \bigskip
    \begin{findincompatiblecorrectness}
        \label{lem:findincompatiblecorrectness}

        The algorithm \texttt{Find\_Incompatible}$(u, T_B)$ outputs $incompatible(u)$.

        \begin{proof}
            Similarly to Lemma~\ref{lem:incompatiblecandidates}, we let the nodes in $lowerBoundary$ be numbered $1$ to $\beta = |lowerBoundary|$ in the order that they will be iterated over. We define $D_0 = \leafset(T_B[c_1])$ and for any $i$, $1 \leq i \leq \beta$, $D_i = D_0 \cup \bigcup_{j = 1}^{i} \leafset(T_B[r_j])$.

            First, notice that the algorithm follows the same structure for updating $roots$ as \texttt{Compute\_Roots\_Of\_Subtrees}. Then by applying the same arguments as in Lemma~\ref{lem:computerootsofsubtreescorrectness}, we can see that the parent counter invariant is maintained and after $r_i$ is processed, $roots = rootsOfSubtrees(D_i)$.

            The set $candidates$ is initialised to exactly $candidates_0$.

            Note that the inner loop discovers one new node $r \in rootsOfSubtrees(D_i)$ and removes any node $r' \in rootsOfSubtrees(D_{i-1})$ from $roots$ iff $r'$ is a proper descendant of $r$. The algorithm then adds $path(parent^{T_B}(r), l_u)$ to $candidates$ if $parent^{T_B}(r) \not\in candidates$.

            We claim that after the inner loop terminates, $candidates = candidates_{i-1} - V(T_B[r])$. Take any node $v \in candidates_{i-1} \cap V(T_B[r])$. Since $v \in candidates_{i-1}$, there is some $r' \in rootsOfSubtrees(D_{i-1})$ such that $v \in path(parent^{T_B}(r'), l_{c_1})$. Since $v$ is a proper ancestor of $r'$, there is some leaf $x \in \leafset(T_B[v])$ such that $x \not\in D_{i-1}$. If $v$ is not a proper ancestor of $r_i$, then $x \not\in \leafset(T_B[r_i])$ and so $x \not\in D_i$. But since $v \in V(T_B[r])$, $x \in \leafset(T_B[r])$, which is a contradiction as $\leafset(T_B[r]) \subseteq D_i$. Thus $v$ is a proper ancestor of $r_i$. Since the inner loop removes all nodes in $path(r_i, parent^{T_B}(r))$ from $candidates$, when this loop terminates, $v \not\in candidates$.

            Then if $parent^{T_B}(r) \in candidates$, $path(parent^{T_B}(r), l_u) \subseteq candidates$. This is because $candidates_{i-1}$ consists only of paths between nodes from $rootsOfSubtrees(D_{i-1})$ and $l_u$, so for any node $v \in candidates_i$, $path(v, l_u) \subseteq candidates_i$. Removing an entire subtree does not break this property, so it holds for $candidates_i - V(T_B[r]) = candidates$.

            Thus when we finish processing $r_i$, $candidates = (candidates_{i-1} - V(T_B[r])) \cup path(parent^{T_B}(r), l_u) = candidates_i$. As mentioned earlier, $candidates_{\beta} = incompatible(u)$, so \texttt{Find\_Incompatible}$(u, T_B)$ returns $incompatible(u)$.
        \end{proof}
    \end{findincompatiblecorrectness}

    These results now lead us to the solution for \texttt{Filter\_Clusters}. We define a subroutine \texttt{Filter\_Clusters\_Helper} which takes as input a subtree of $T_A$ (say $T_A[u]$) and $T_B$. It returns $rootsOfSubtrees(\leafset(T_A[u]))$. As a side effect, any node $u' \in V(T_A[u])$ is marked for deletion if $w(u') \leq max(\{w(C_1) : C_1 \in \mathcal{C}(T_B) \text{ and } C_1 \not\compatible \leafset(T_A[u'])\})$. This means that any node in $T_A$ which is not more frequent that every cluster it is incompatible with in $T_B$ is marked for deletion. Then \texttt{Filter\_Clusters} uses \texttt{Filter\_Clusters\_Helper} in the following manner:

    \begin{algorithm}
        \caption{Filter\_Clusters}
        \begin{algorithmic}[1]
            \Input Trees $T_A$ and $T_B$ with $\leafset(T_A) = \leafset(T_B) = L$ where every cluster has a known $weight$.

            \Output A tree $T$ where $\mathcal{C}(T) = \{C : C \in \mathcal{C}(T_A) \text{ and } w(C) > max(\{w(C_1) : C_1 \in \mathcal{C}(T_B) \text{ and } C_1 \not\compatible C\})\}$ and $\leafset(T) = L$

            \State Preprocess $T_B$ for $lca$ queries

            \State Do a bottom-up traversal of $T_B$ to compute $|\leafset(T_B[v])|$ for all $v \in V(T_B)$

            \State Construct an RMQ structure over $T_B$

            \State Let $T_{A1} :=$ copy of $T_A$

            \State \texttt{Filter\_Clusters\_Helper}$(T_{A1}, T_B)$

            \State Do a top-down traversal of $T_{A1}$, deleting all marked nodes

            \State \Return $T_{A1}$
        \end{algorithmic}
    \end{algorithm}

    At this point, we are ready to describe \texttt{Filter\_Clusters\_Helper}. This algorithm uses the \textit{centroid path decomposition technique} of \cite{cole2000n} to decompose $T_A$ into a \textit{centroid path} and a set of \textit{side trees} (similarly to \cite{jansson2018algorithms}). A \textit{centroid path} in $T_A$ is the path formed by starting at the root and at each point following the child with the largest leaf set. The centroid path is denoted by $\pi = \langle p_{\alpha}, p_{\alpha - 1}, ..., p_1 \rangle$, where $p_{\alpha}$ is the root of $T_A$ and $p_1$ is a leaf. Removing all nodes in $\pi$ along with all associated edges from $T_A$ results in a set of disjoint subtrees of $T_A$, where the root of each such subtree is a child of some node in $\pi$. These trees are called the \textit{side trees} of $\pi$, denoted by $\sigma(\pi)$. Also let $\sigma(p_i)$ be the set of side trees whose roots are children of $p_i$, called the side trees \textit{associated} with $p_i$. Observe that for any side tree $\tau \in \sigma(\pi)$, $|\leafset(\tau)| \leq n/2$ and that $\{\leafset(\tau) : \tau \in \sigma(\pi)\}$ forms a partition of $L\, \backslash\, {p_1}$. We further note that for any $i \geq 2$, $\leafset(T_A[p_{i - 1}]) \subset \leafset(T_A[p_i])$, i.e. the cluster associated with $p_{i-1}$ is a proper subset of $p_i$. This then leads to the intuition behind \texttt{Filter\_Clusters\_Helper} - recursively compute \texttt{Filter\_Clusters\_Helper} for side trees, then for the nested clusters rooted at nodes in the centroid path, use Algorithm~\ref{alg:computerootsofsubtrees} to find the maximal compatible subtrees and Algorithm~\ref{alg:findincompatible} to find incompatible nodes.

    The algorithm initialises $roots$ with $p_1$ and sets up the parent counter invariant. It then uses the same structure as in Algorithm~\ref{alg:computerootsofsubtrees} and Algorithm~\ref{alg:findincompatible} to find the nodes incompatible with any $p_i \in \pi$. Thus it uses $incompatible(p_{i-1})$ and $rootsOfSubtrees(c)$ for each $c \in children(p_i) - \{p_{i-1}\}$ to compute $incompatible(p_i)$. To facilitate this process, \texttt{Filter\_Clusters\_Helper} returns $rootsOfSubtrees(\leafset(T_A))$ for the caller to use. Once $incompatible(p_i)$ is computed, we compare the largest weight in this set with the weight of $p_i$, and mark $p_i$ for deletion if its weight is not larger.

    A crucial optimisation we make in this algorithm is utilising an RMQ structure on $T_B$ that allows us to query for the maximum weight of any node on the path between two given nodes. This is because we do not actually need the set of incompatible nodes, we just need to find the largest weight over all incompatible nodes. Thus, rather than inserting all the nodes in say $path(v, v')$ into candidates, we just insert $maxWeight(path(v, v'))$ obtained from the RMQ structure. To delete a node from $candidates$, we remove its entry and instead insert its parent.

    Finally note that we need to erase the counter values set in a call to \texttt{Filter\_Clusters\_Helper}, otherwise they will interfere with the processing of other calls. However, observe that we do not need to erase counters of any node in a compatible subtree, since those nodes will never be encountered again. Further, due to the way the algorithm is structured, the only other counters that are set are those of the parents of these subtrees, and this is done at the end of a given call to the function.

    The resulting algorithm (Algorithm~\ref{alg:filterclustershelper}) is presented on the next page.

    \begin{algorithm}
        \caption{Filter\_Clusters\_Helper}
        \label{alg:filterclustershelper}

        \begin{algorithmic}[1]
            \Input Trees $T_A$ and $T_B$ with $\leafset(T_A) \subseteq \leafset(T_B) = L$ where every cluster has a known $weight$.

            \SideEffect Marks any node $u' \in V(T_A)$ for deletion iff $w(u') \leq w(v)$ for any $v \in V(T_B)$ with $\leafset(T_A[u']) \not\compatible \leafset(T_B[v])$.

            \Output $rootsOfSubtrees(\leafset(T_A))$

            \State Compute a centroid path $\pi = \langle p_{\alpha}, p_{\alpha - 1}, ..., p_1 \rangle$ of $T_A$, where $p_{\alpha}$ is the root of $T_A$ and $p_1$ is a leaf.

            \State \algorithmicforall\ side trees $\tau \in \sigma(\pi)$,
                associate \texttt{Filter\_Clusters\_Helper}$(\tau, T_B)$ with $\tau$

            \State Let $l_1 :=$ leaf in $T_B$ labelled by $p_1$

            \State $counter(l_1) := 1$ and $counter(parent^{T_B}(l_1)) := 1$

            \State $roots := \{l_1\}$

            \State $candidates :=$ empty Brodal queue

            \For{$i := 2$ \textbf{to} $\alpha$}
                \State $lowerBoundary := \{\}$

                \ForAll{side trees $\tau$ associated with $p_i$}
                    \State $lowerBoundary := roots\ \cup$ list of roots associated with $\tau$
                \EndFor

                \State $l_i := lca^{T_B}(l_{i-1} \cup lowerBoundary)$

                \If{$counter(l_{i-1}) \not\in roots$}
                    \State Insert $l_{i-1}, maxWeight(path(l_{i-1}, l_i))$ into $candidates$
                \Else
                    \State Insert $parent^{T_B}(l_{i-1}), maxWeight(path(parent^{T_B}(l_{i-1}), l_i))$ into $candidates$
                \EndIf

                \ForAll{$v \in lowerBoundary$}
                    \State $counter(parent^{T_B}(v)) := counter(parent^{T_B}(v)) + |\leafset(T_B[v])|$

                    \State $roots := roots \cup \{v\}$

                    \State $v := parent^{T_B}(v)$

                    \While{$counter(v) = |\leafset(T_B[v])|$}
                        \State $counter(parent^{T_B}(v)) := counter(parent^{T_B}(v)) + |\leafset(T_B[v])|$

                        \IIf{$v \in candidates$} remove $v$ from $candidates$

                        \State $roots := (roots \cup \{v\}) - children(v)$

                        \State $v := parent^{T_B}(v)$
                    \EndWhile

                    \IIf{$v \not\in candidates$} insert $v, maxWeight(path(v, l_i))$ into $candidates$
                \EndFor

                \IIEf{$candidates$ is empty}
                    {$M := 0$}
                    $M :=$ maximum weight of a node in $candidates$

                \IIf{$w(\leafset(T_A[p_i])) \leq M$}
                    mark $p_i$ for deletion
            \EndFor

            \State \algorithmicforall\ $r \in roots$, $counter(parent^{T_B(r)}) := 0$

            \State \Return $roots$
        \end{algorithmic}
    \end{algorithm}

    \bigskip
    \begin{filterclustersruntime}
        \label{lem:filterclustersruntime}

        The algorithm \texttt{Filter\_Clusters}$(T_A, T_B)$ runs ins $O(n\,log\,n)$ time.

        \begin{proof}
            We preprocess $T_B$ for \textit{lca} queries using the technique of \cite{bender2000lca}. This takes $O(n)$ preprocessing time and thereafter allows us to answer \textit{lca} queries in $O(1)$ time. $T_B$ is also preprocessed for RMQ queries using Lemma 8 of \cite{jansson2018algorithms}. This takes $O(n\,log\,n)$ preprocessing time and thereafter allows us to answer $maxWeight$ queries in $O(1)$ time. The bottom-up traversal of $T_B$ to compute $|leafset(T_B[v])|$ for all $v \in V(T_B)$ takes $O(n)$ time. Finally, copying $T_A$ takes $O(n)$ time.

            The helper algorithm uses a number of sets of nodes. To implement each of these, we utilise a linked list, while augmenting the node with a property that allows it to know whether it belongs to the set or not. In this manner, we can ensure that these sets do not contain duplicates and membership/addition/deletion operations can be done in constant time. The same is done for for the $candidates$ structure to allow membership queries.

            The data structure used for $candidates$ is the Brodal queue of \cite{brodal1995fast}. This allows insertion and findMax in $O(1)$ time and delete in $O(log\,m)$ time (where $m$ is the number of elements in the queue). Since the number of nodes in $T_B$ is $O(n)$, the number of elements in the queue is always $O(n)$ and so deletions cost $O(log\,n)$ time.

            Let $m = |\leafset(T_A)|$ for some call to \texttt{Filter\_Clusters\_Helper}$(T_A, T_B)$. Observe that for any cluster $C$, the number of compatible subtrees that can be discovered is $O(|C|)$. Recall that $n = |\leafset(T_B)|$.

            Computing the centroid path takes $O(m)$ time. Since the total number of leaves over all side trees is $O(m)$, the additions to $rootsOfSubtrees$ and $lowerBoundary$ cost $O(m)$ time. Similarly, since $lca$ queries can be made in constant time and the total number of $lca$ queries is $O(m)$, this also costs $O(m)$ time. It remains to analyse the upward iterations. First, note that this loop is entered a total of $O(m)$ times. Secondly, by Lemma~\ref{lem:filterclusterssubsetcompatible}, we know that a node that is removed from a $candidates$ set will never be inserted into any $candidates$ set again. Thus any node will only enter this inner loop once. All operations within this are $O(log\,n)$, so total time inside this loop is $O(n\,log\,n)$. The exception to this analysis is the step that removes all children of $x$ from $rootsOfSubtrees$. Since any node will be removed from $rootsOfSubtrees$ only once, this step costs $O(n)$ time total.

            Thus we can write a recurrence for \texttt{Filter\_Clusters\_Helper} (ignoring steps that are being analysed over the entire call to \texttt{Filter\_Clusters}) in the following manner: $T(m) = \sum_{\tau \in \sigma(\pi)}T(|\leafset(\tau))|) + O(m)$. Since for any $\tau \in \sigma(\pi)$, $|\leafset(\tau)| \leq m/2$, there are $log\,m$ recursion levels, we get $T(n) = O(n\,log\,n)$.

            Finally, we note that time taken to process $T_{A1}$ after \texttt{Filter\_Clusters\_Helper} is done takes $O(n)$ time. This is because deleting all marked nodes can be done in a top down traversal, where every node's parent changes at most once. Further, recall that the total preprocessing time is $O(n\,log\,n)$ and the time set aside to be analysed over the entire call to \texttt{Filter\_Clusters} is $O(n\,log\,n)$. Thus, \texttt{Filter\_Clusters} runs in $O(n\,log\,n)$ time.
        \end{proof}
    \end{filterclustersruntime}

    \subsection{\texttt{Frequency\_Difference}}

    \begin{freqdiffruntime}
        \label{theorem:freqdiffruntime}

        The algorithm \texttt{Frequency\_Difference} runs in $O(kn\,log\,n)$ time.

        \begin{proof}
            By Corollary~\ref{cor:freqdiffruntimecomponents} and Lemmas~\ref{lem:labelclustersruntime} and~\ref{lem:filterclustersruntime}, \texttt{Frequency\_Difference} runs in $O(kn\,log\,n + k \cdot n\,log\,n) = O(kn\,log\,n)$ time.
        \end{proof}
    \end{freqdiffruntime}

    \section{Future Work}
    \label{sec:futurework}

    I plan on looking into the following items over the coming semester:
    \begin{itemize}
        \item The writeup above is perhaps too verbose; it might be possible to make it more concise. It might also be possible to improve the presentation of the algorithm.
        \item The algorithm presented above needs to be implemented and experimental results obtained.
        \item There are further types of consensus trees that I can investigate. I will likely pick up greedy consensus trees next and attempt to improve on the best known time presented in \cite{gawrychowski2017faster}.
    \end{itemize}

    \newpage
    \bibliographystyle{plain}
    \bibliography{interim_report}
\end{document}
