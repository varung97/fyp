\documentclass{article}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{enumerate}
\usepackage{relsize}
\usepackage{algorithm}
\usepackage{algpseudocode}

\usepackage[
  top    = 2.75cm,
  bottom = 3.00cm,
  left   = 2.50cm,
  right  = 2.50cm
]{geometry}
\setlength{\parindent}{0in}

\algnewcommand\algorithmicinput{\textbf{Input:}}
\algnewcommand\algorithmicoutput{\textbf{Output:}}
\algnewcommand\Input{\item[\algorithmicinput]}
\algnewcommand\Output{\item[\algorithmicoutput]}
\algnewcommand{\IIf}[1]{\State\algorithmicif\ #1\ \algorithmicthen}
\algnewcommand{\IIEf}[2]{\State\algorithmicif\ #1\ \algorithmicthen\ #2\ \algorithmicelse}
\newcommand{\compatible}{\smile}
\newcommand{\leafset}{\Lambda}

\title{CG4001 Interim Report}
\author{Varun Gupta\\A0147924X}

\newtheorem{incompatibility}{Lemma}
\newtheorem{mergetrees}[incompatibility]{Lemma}
\newtheorem{freqdiffruntime}[incompatibility]{Corollary}
\newtheorem{assocnode}[incompatibility]{Lemma}
\newtheorem{labelclusterscorrectness}[incompatibility]{Lemma}
\newtheorem{labelclustersruntime}[incompatibility]{Lemma}
\newtheorem{filterclusterssubsetcompatible}[incompatibility]{Lemma}
\newtheorem{filterclustersfindingincompatible}[incompatibility]{Lemma}
\newtheorem{filterclustersfindingcompatible}[incompatibility]{Lemma}
\newtheorem{filterclustersfindingcompatibletermination}[incompatibility]{Lemma}

\begin{document}
    \maketitle
    % \newpage

    \begin{abstract}
        This report presents a new deterministic algorithm for constructing a frequency difference consensus tree. Given $k$ phylogenetic trees with identical leaf label sets of size $n$, this algorithm constructs the frequency difference tree in $O(kn\,log\,n)$ time, bettering the previously best known time of $O(kn\,log^2n)$.
    \end{abstract}
    % \newpage

    % \tableofcontents
    % \newpage

    \section{Introduction}
    A \textit{taxon} (pl. taxa) is a group of organisms that taxonomists classify as a single unit, such as \textit{homo sapiens}. A \textit{rooted phylogenetic tree} is one that presents the evolutionary relationships between various taxa. Here, the root represents their common ancestor, and children of nodes split each group into smaller ones. A \textit{consensus tree} reconciles multiple phylogenetic trees, summarising the branching information contained in each into a single tree. This report studies a specific type of consensus tree, known as the \textit{frequency difference consensus tree} and arrives at a fast algorithm for constructing this.

    \subsection{Definitions and Notation}
    We define a rooted phylogenetic tree to be a rooted, leaf-labelled tree where every internal node has 2 or more children and every leaf has a different label. Henceforth, we will simply refer to these as trees. For any tree $T$, let $V(T)$ be the vertex set of $T$ and $\leafset(T)$ be the leaf set of $T$. Non-empty subsets of $\leafset(T)$ are called \textit{clusters}. Clusters with cardinality $1$ or $|\leafset(T)|$ are \textit{trivial clusters}. For any $u \in V(T)$, $T[u]$ is the subtree of $T$ rooted at $u$. Then $\leafset(T[u])$ is the cluster associated with $u$. The \textit{cluster collection} of $T$, $\mathcal{C}(T)$ is the set $\bigcup_{u \in V(T)} {\leafset(T[u])}$, i.e. a set containing all the clusters in $T$. Any cluster $C \subseteq \leafset(T)$ \textit{occurs} in $T$ iff $C \in \mathcal{C(T)}$. Also define, for any tree $T$, for any cluster $C \subseteq \leafset(T)$, $lca^T(C)$ to be the least common ancestor of $C$ in $T$.\\

    Any two clusters $C_1, C_2 \in \mathcal{C}(T)$ are said to be \textit{compatible}, denoted as $C_1 \compatible C_2$, iff $C_1 \subseteq C_2$ or $C_2 \subseteq C_1$ or $C_1 \cap C_2 = \emptyset$. If $C_1$ and $C_2$ satisfy none of the preceding properties, then they are said to be \textit{incompatible}, denoted as $C_1 \not\compatible C_2$. We now extend the notion of compatibility to trees. A cluster $C \subseteq \leafset(T)$ is \textit{compatible} with $T$ iff for every $u \in V(T)$, $C \compatible \leafset(T[u])$. Further, two trees $T_1$ and $T_2$ satisfying $\leafset(T_1) = \leafset(T_2)$ are \textit{compatible} iff for every $u \in V(T_1)$, $\leafset(T_1[u]) \compatible T_2$, i.e. if every cluster in $T_1$ is compatible with $T_2$. Observe that this also means that every cluster in $T_2$ is compatible with $T_1$.\\

    A \textit{frequency difference consensus tree} can then be defined as thus. Let $\mathcal{S}$ be a set of $k$ trees with identical leafs labels, i.e. $\mathcal{S} = \{T_1, T_2, ..., T_k\}$, where $\leafset(T_1) = \leafset(T_2) = ... = \leafset(T_k) = L$. For any cluster $C \subseteq L$, let $K_C = \{T : T \in \mathcal{S} \text{ and } C \in \mathcal{C}(T)\}$ be the set of trees in $\mathcal{S}$ which $C$ occurs in. Let $T_{FD}$ be the frequency difference consensus tree of $\mathcal{S}$, with $\mathcal{C}(T_{FD}) = \{C : C \subseteq L \text{ and } |K_C| > max(\{|K_{C_1}| : C_1 \subseteq L \text{ and } C \not\compatible C_1\})\}$. Thus $T_{FD}$ contains all clusters that occur more frequently than any cluster that they are incompatible with. By Proposition $3$ in \cite{steel2014axiomatic}, this tree always exists and is unique for a given $\mathcal{S}$. [Need example]\\

    Henceforth, $\mathcal{S}$ is taken to be the input set of trees with identical leaf labels. This set of leaf labels is denoted by $L$. Let $|\mathcal{S}| = k$ and $|L| = n$.

    \subsection{Previous Work}
    Jansson et al. \cite{jansson2018algorithms} gave a deterministic $min\{O(kn^2), O(kn(k + log^2 n))\}$ algorithm for constructing the frequency difference tree. Gawrychowski et al. \cite{gawrychowski2017faster} improved this to a deterministic $O(kn\,log^2n)$ algorithm.

    \subsection{Organisation of the Article and New Results}
    Section 2 contains some results from previous works that are utilised later. Section 3 presents a new deterministic algorithm for constructing the frequency difference tree that runs in $O(kn\,log\,n)$ time. Section 4 lays out plans for future work.

    \section{Preliminaries}

    % TODO: Need delete not insert
    \subsection{The \textit{insert} operation}
    The \textit{insert} operation inserts a cluster into a tree. To do so, we specify some internal node $u$ in a tree $T$ and a proper subset of its children $X$, where $|X| \geq 2$. Then the \textit{insert} operation creates a new child $v$ of $u$, detaches all nodes in $X$ from $u$ and makes them children of $v$. This creates a new cluster in $T$, of the form $\bigcup_{x \in X}\leafset(T[x])$ while not changing any of the existing clusters. Observe that this process takes $O(|X|)$ time.

    \subsection{Characterising incompatibility}
    We restate Lemma 6 of \cite{jansson2018algorithms} here since it is crucial in the development of an algorithm discussed below:

    \begin{incompatibility}
        \label{lem:incompatibility}

        Given a tree $T$ and a cluster $C \subseteq \leafset(T)$, let $r_C = lca^T(X)$. Then for any $u \in V(T)$, $C \not\compatible \leafset(T[u])$ iff $u$ lies on the path between $r_C$ and some $x \in C$ and $\leafset(T[u]) \not\subseteq C$.
    \end{incompatibility}

    \subsection{Subroutines}
    This article uses the procedure \texttt{Merge\_Trees} from \cite{jansson2016improved}. \texttt{Merge\_Trees} takes two compatible trees $T_A$ and $T_B$ with identical leaf labels and outputs a tree with the same leaf labels which contains all the clusters in $T_A$ and $T_B$. This is formalized below:

    \begin{mergetrees}
        \label{lem:mergetrees}

        Let $T_A$ and $T_B$ be two compatible trees with $\leafset(T_A) = \leafset(T_B) = L$ and $|L| = n$. Procedure \texttt{Merge\_Trees} takes $T_A$ and $T_B$ and outputs tree $T$ with $\leafset(T) = L$ and $\mathcal{C}(T) = \mathcal{C}(T_A) \cup \mathcal{C}(T_B)$ in $O(n)$ time.
    \end{mergetrees}

    \subsection{\texttt{Frequency\_Difference} algorithm}
    The algorithm \texttt{Frequency\_Difference} is laid out in \cite{jansson2018algorithms}. Before describing this, we first define the weight of a node to be the number of trees in $\mathcal{S}$ that the the cluster associated with $u$ occurs in. Formally, for any tree $T \in \mathcal{S}$ and any node $u \in V(T)$, let $C = \leafset(T[u])$, then $weight(u) = w(u) = |K_C|$ and also let $w(C) = w(u)$. Further, define a procedure \texttt{Filter\_Clusters} which takes in trees $T_A$ and $T_B$, with $\leafset(T_A) = \leafset(T_B) = L$ and $w(u)$ computed for any $u \in V(T_A) \cup V(T_B)$. It returns a tree $T$ which contains all clusters $C$ in $T_A$ for which $w(C) > $ weight of all clusters in $T_B$ that it is incompatible with. Formally, \texttt{Filter\_Clusters}$(T_A, T_B) = T$ where $\mathcal{C}(T) = \{C : C \in \mathcal{C}(T_A) \text{ and } w(C) > max(\{w(C_1) : C_1 \in \mathcal{C}(T_B) \text{ and } C_1 \not\compatible C\})\}$ and $\leafset(T) = L$.\\

    Then the algorithm \texttt{Frequency\_Difference} runs in two parts. First, for any tree $T \in \mathcal{S}$ and any node $u \in V(T)$, it computes $w(u)$. We call this the \textit{labelling} step. In the second part, it utilises \texttt{Filter\_Clusters} and \texttt{Merge\_Trees} to compute the frequency difference consensus tree. Theorem 3 of \cite{jansson2018algorithms} gives the following corollary:

    \begin{freqdiffruntime}
        \label{cor:freqdiffruntime}

        The total runtime of \texttt{Frequency\_Difference} is given by $O(g(n, k) + k \cdot f(n))$ where $g(n, k)$ is the time taken by the labelling step and $f(n)$ is the runtime of \texttt{Filter\_Clusters}.
    \end{freqdiffruntime}

    Jansson et al. \cite{jansson2018algorithms} gave a $min(\{O(kn^2), O(k^2n)\})$ solution to the labelling step and an $O(n\,log^2n)$ solution to \texttt{Filter\_Clusters}, giving an overall runtime of $min(\{O(kn^2), O(kn(k + log^2n))\})$. Gawrychowski et al. \cite{gawrychowski2017faster} improved the runtime of the labelling step to $O(kn\,log^2n)$, thus reducing the overall runtime to $O(kn\,log^2n)$.\\

    \section{Constructing the Frequency Difference Consensus Tree}
    We present an $O(kn\,log\,n)$ solution for the labelling step in section 3.1 and an $O(n\,log\,n)$ solution for \texttt{Filter\_Clusters} in section 3.2. Taken together with Corollary 2, this allows us to solve \texttt{Frequency\_Difference} in $O(kn\,log\,n)$ time.

    \subsection{Labelling}
    As in \cite{gawrychowski2017faster}, we divide the labelling step into two parts. First, we give a label to every node $u$, where $u \in V(T)$ for some $T \in \mathcal{S}$, denoted by $id(u)$. The labels obey the restrictions that $id(u) \in [1, kn]$ and for some $u' \in T'$, $T' \in \mathcal{S}$, $id(u) = id(u')$ iff $\leafset(T[u]) = \leafset(T'[u'])$. That is, two nodes will have the same label iff they are associated with the same cluster. Second, we counting sort these labels, allowing us to count how many nodes exist with a certain label, giving us the frequency of those nodes in $\mathcal{S}$.\\

    First, for some tree $T$ and some cluster $C \subseteq \leafset(T)$ define $T|C$, read as ``$T$ restricted to $C$'', as the tree $T'$ with $V(T') = \{lca^T(u, v) : u, v \in C\}$ which obeys $lca^T(C') = lca^{T'}(C')$ for all nonempty $C' \subseteq C$. Intuitively, $T'$ has the leaf set $C$ and consists of all nodes in $T$ that are $lca$'s of the leafs in $C$, with these nodes connected such that they have the same ancestor/descendant relationships as they had in $T$. Further, for any node $u$ in $T$, define the node that $u$ is associated with when $T$ is restricted to $C$ to be the descendant of $u$ with least depth that is in $T|C$, denoted as $assoc^{C}(u)$.\\

    The algorithm \texttt{Label\_Clusters} is laid out below.

    \begin{algorithm}
        \caption{Label\_Clusters}
        \begin{algorithmic}[1]
            \Input A set $\mathcal{S}$ of trees $\{T_1, T_2, ..., T_k\}$ where $\leafset(T_1) = \leafset(T_2) = ... = \leafset(T_k) = L$
            \Output Every node in the trees in $\mathcal{S}$ is labelled such that nodes associated with the same cluster have the same labels and for any $u$, $id(u) \in [1, k |L|]$

            \State Partition $L$ into $L'$ and $L''$ such that $|L'| = |L''|$.
            \State For all $i \in [1,k]$, let $T'_i = T_i|L'$ and $T''_i = T_i|L''$.
            \State \texttt{Label\_Clusters}$(T'_1, T'_2, ..., T'_k)$.
            \State \texttt{Label\_Clusters}$(T''_1, T''_2, ..., T''_k)$.
            \State For every tree $T \in \mathcal{S}$, for every node $u \in T$, represent $u$ by the pair $(id(assoc^{L'}(u)), id(assoc^{L''}(u)))$.
            \State Radix sort all pairs obtained. Assign each set of duplicates found thus a rank.
            \State For every tree $T \in \mathcal{S}$, for every node $u \in T$, set $id(u) = $ rank of the pair $(id(assoc^{L'}(u)), id(assoc^{L''}(u)))$.
        \end{algorithmic}
    \end{algorithm}

    \begin{assocnode}
        \label{lem:assocnode}

        For any tree $T$, for any node $u \in V(T)$ and any cluster $C \subseteq \leafset(T)$, $\leafset(T|C[assoc^C(u)]) = \leafset(T[u])\, \cap\, C$.

        \begin{proof}
            First note that for any node $v \in V(T|C)$, $\leafset(T|C[v]) = \leafset(T[v])\, \cap\, C$ due to the way $T|C$ is constructed. Also, $\leafset(T[assoc^C(u)]) \subseteq \leafset(T[u])$ since $assoc^C(u)$ is a descendant of $u$. Thus $\leafset(T[assoc^C(u)])\, \cap\, C \subseteq \leafset(T[u])\, \cap\, C$ and so $\leafset(T|C[assoc^C(u)]) \subseteq \leafset(T[u])\, \cap\, C$.\\

            This implies that if $\leafset(T|C[assoc^C(u)]) \neq \leafset(T[u])\, \cap\, C$ then there is some leaf $x$ such that $x \in \leafset(T[u])\, \cap\, C$ and $x \not\in \leafset(T|C[assoc^C(u)])$. Then let $v = lca^T(C \cup x)$. Observe that $v$ is proper ancestor of $u$, since $\leafset(T[u]) = C \subseteq C \cup x = \leafset(T[v])$ and $\leafset(T[u]) \neq \leafset(T[v])$. Also, since $v = lca^T(C \cup x)$ and $C \cup x \subseteq \leafset(T[u])$, $v$ is a descendant of $u$. Finally, $v \in V(T|C)$. But then an ancestor of $v$ would be $assoc^C(u)$, and not the node that was initially obtained.
        \end{proof}
    \end{assocnode}

    \begin{labelclusterscorrectness}
        \label{lem:labelclusterscorrectness}

        After running \texttt{Label\_Clusters}$(\mathcal{S})$, for any trees $T_i, T_j \in \mathcal{S}$, for any nodes $u \in V(T_i), v \in V(T_j)$, $id(u) = id(v)$ iff $\leafset(T_i[u]) = \leafset(T_j[v])$.

        \begin{proof}
            $id(u) = id(v)$ iff $id(assoc^{L'}(u)) = id(assoc^{L'}(v))$ and $id(assoc^{L''}(u)) = id(assoc^{L''}(v))$. Inductively, the first part is true iff $\leafset(T_i|L'[assoc^{L'}(u)]) = \leafset(T_j|L'[assoc^{L'}(v)])$. By Lemma~\ref{lem:assocnode}, $\leafset(T_i[u])\, \cap\, L' = \leafset(T_j[v])\, \cap\, L'$. Symmetrically, the second part is true iff $\leafset(T_i[u])\, \cap\, L'' = \leafset(T_j[v])\, \cap\, L''$. Since $L'$ and $L''$ partition $L$, both parts are true iff $\leafset(T_i[u]) = \leafset(T_j[v])$.
        \end{proof}
    \end{labelclusterscorrectness}

    \begin{labelclustersruntime}
        \label{lem:labelclustersruntime}

        The algorithm \texttt{Label\_Clusters}$(\mathcal{S})$ runs in $O(kn\,log\,n)$ time.

        \begin{proof}
            Let $T(m)$ be the runtime of \texttt{Label\_Clusters}$(\mathcal{T})$, where $m =$ size of leaf set of each tree in $\mathcal{T}$. By Lemma 5.2 of \cite{farach1995fast}, construction of $T'_i$ and $T''_i$ takes $O(m)$ time for each $T_i \in \mathcal{T}$, taking total $O(km)$ time over all the trees. For each $T_i \in \mathcal{T}$, $|V(T_i)| = O(m)$. Computing $assoc^{L'}(u)$ and $assoc^{L''}(u)$ for each node $u$ in some tree $T_i \in \mathcal{T}$ can be done by a bottom up traversal of $T_i$ along with $T'_i$ and $T''_i$, taking $O(km)$ time total. Also observe that the number of pairs obtained is $O(km)$. Further, each of the values in the pair are in the range [1, km/2]. Thus radix sorting these pairs and assigning labels back to the nodes takes $O(km)$ time. So $T(m) = 2T(m/2) + O(km)$, giving $T(n) = kn\,log\,n$.
        \end{proof}
    \end{labelclustersruntime}

    \subsection{\texttt{Filter\_Clusters}}

    We first prove two important lemmas.

    \begin{filterclusterssubsetcompatible}
        \label{lem:filterclusterssubsetcompatible}

        Let nodes $u \in V(T_A)$, $v \in V(T_B)$ such that $\leafset(T_B[v]) \subseteq \leafset(T_A[u])$. Then for any $w \in V(T_A) - V(T_A[u])$, $\leafset(T_A[w]) \compatible \leafset(T_B[v])$.

        \begin{proof}
            There are two cases for $w$. Case 1: $w$ is on the path from $u$ to $root(T_A)$. Then $\leafset(T_A[u]) \subseteq \leafset(T_A[w])$. Thus $\leafset(T_B[v]) \subseteq \leafset(T_A[w])$, and so $\leafset(T_B[v]) \compatible \leafset(T_A[w])$. Case 2: $w$ is not on the path from $u$ to $root(T_A)$. Since $w$ is also not a descendant of $u$, $\leafset(T_A[w]) \cap \leafset(T_A[u]) = \emptyset$. Thus $\leafset(T_A[w]) \cap \leafset(T_B[v]) = \emptyset$ and so $\leafset(T_B[v]) \compatible \leafset(T_A[w])$.
        \end{proof}
    \end{filterclusterssubsetcompatible}

    Additionally, notice that the same holds for any node $x \in V(T_B[v])$, since $\leafset(T_B[x]) \subseteq \leafset(T_B[v])$. Thus, the upshot of Lemma~\ref{lem:filterclusterssubsetcompatible} is that if a certain node $v \in V(T_B)$ is deemed to have a leafset that is a subset of some node $u \in V(T_A)$, then $v$ is the root of a subtree of $T_B$ that does not need to be ever considered again when attempting to determine which nodes in $V(T_B)$ are incompatible with nodes in $V(T_A) - V(T_A[u])$.

    \begin{filterclustersfindingincompatible}
        \label{lem:filterclustersfindingincompatible}

        For any cluster $C \subseteq L$, define $r_C$ to be $lca^{T_B}(C)$. Let node $u \in V(T_A)$, then for some node $v \in V(T_B)$, if $\leafset(T_B[v]) \not\compatible \leafset(T_A[u])$ and for each $c \in children(u)$, $\leafset(T_B[v]) \compatible \leafset(T_A[c])$, then $v$ is a proper descendant of $r_{\leafset(T_A[u])}$ and for some $c \in children(u)$, $v$ is an ancestor of $r_{\leafset(T_A[c])}$.

        \begin{proof}
            Firstly, $v$ has to be a proper descendant of $r_{\leafset(T_A[u])}$ by Lemma~\ref{lem:incompatibility}. Further, for each $c \in children(u)$, $\leafset(T_B[v]) \not\subseteq \leafset(T_A[c])$, since $\leafset(T_A[c]) \subseteq \leafset(T_A[u])$, which would mean that $\leafset(T_B[v]) \compatible \leafset(T_A[u])$. Thus, for each $c \in children(u)$, $\leafset(T_B[v]) \cap \leafset(T_A[c]) = \emptyset$ or $\leafset(T_A[c]) \subseteq \leafset(T_B[v])$, since $\leafset(T_B[v]) \compatible \leafset(T_A[c])$. Assume that for each $c \in children(u)$, $\leafset(T_B[v]) \cap \leafset(T_A[c]) = \emptyset$. Since $\leafset(T_A[u]) = \bigcup_{c \in children(u)} \leafset(T_A[c])$, $\leafset(T_B[v]) \cap \leafset(T_A[u]) = \emptyset$. But then $\leafset(T_B[v]) \compatible \leafset(T_A[u])$. Thus there is some $c \in children(u)$, $\leafset(T_A[c]) \subseteq \leafset(T_B[v])$. Then $v$ is an ancestor of $r_{\leafset(T_A[c])}$.
        \end{proof}
    \end{filterclustersfindingincompatible}

    The upshot of Lemma~\ref{lem:filterclustersfindingincompatible} is that for any node $u \in V(T_A)$, to find nodes in $T_B$ which are incompatible with $u$, we could recursively find all nodes that are incompatible with the children of $u$. Then, for each $c \in children(u)$, we add to this set nodes that are ancestors of $r_{\leafset(T_A[c])}$, going up until $r_{\leafset(T_A[u])}$. This is then a superset of the nodes that are incompatible with $u$.

    \begin{filterclustersfindingcompatible}
        \label{lem:filterclustersfindingcompatible}

        For any node $u \in V(T_A)$, let $I$ be a set of candidate incompatible nodes from $T_B$ constructed using the process described above. Then any node $v$ in $I$ that is in fact compatible with $u$ is of the following form: $v$ is a proper descendant of $u$ and for some $x \in leafset(T_A[u])$, $v$ is a proper ancestor of $x$.

        \begin{proof}
            For any node $v$ in $I$, $v$ is either incompatible with some $c \in children(u)$, or for some $c \in children(u)$, $v$ lies on the path from $r_{\leafset(T_A[c])}$ to $r_{\leafset(T_A[u])}$. Let the child of $u$ associated with $v$ thus be $c$. Then if $v$ is of the first form, then by Lemma~\ref{lem:incompatibility}, for some $x \in \leafset(T_A[c])$, $v$ lies on the path between $x$ and $r_{\leafset(T_A[c])}$. If $v$ is of the second form, then $v$ clearly lies on the path from any $x \in \leafset(T_A[c])$ to $r_{\leafset(T_A[u])}$.
        \end{proof}
    \end{filterclustersfindingcompatible}

    \begin{filterclustersfindingcompatibletermination}
        \label{lem:filterclustersfindingcompatibletermination}

        For any node $u \in V(T_A)$, if for some $v \in V(T_B)$, $\leafset(T_A[u]) \not\compatible \leafset(T_B[v])$, then for any node $w$ on the path between $v$ and $r_{\leafset(T_A[u])}$, $\leafset(T_A[u]) \not\compatible \leafset(T_B[w])$.

        \begin{proof}
            Since $v$ is a descendant of $r_{\leafset(T_A[u])}$ [by Lemma~\ref{lem:incompatibility}], $w$ is an ancestor of $v$. Also, since $\leafset(T_A[u]) \not\compatible \leafset(T_B[v])$, there is some $x \in \leafset(T_B[v])$ such that $x \not\in \leafset(T_A[u])$. Since $\leafset(T_B[v]) \subseteq \leafset(T_B[w])$, $x \in \leafset(T_B[w])$. Also, since $w$ is a proper descendant of $r_{\leafset(T_A[u])}$, there is some $y \in \leafset(T_A[u])$ such that $y \not\in \leafset(T_B[w])$ [otherwise $w$ would be an ancestor of $r_{\leafset(T_A[u])}$]. Thus $\leafset(T_A[u]) \not\compatible \leafset(T_B[w])$.
        \end{proof}
    \end{filterclustersfindingcompatibletermination}

    By Lemmas~\ref{lem:filterclustersfindingcompatible} and~\ref{lem:filterclustersfindingcompatibletermination}, we can see that to remove nodes from the candidate set of incompatible nodes, we need to merely iterate upwards from each $x \in \leafset(T_A[u])$, removing nodes that are compatible, until we hit a node that is incompatible. Further, Lemma~\ref{lem:filterclusterssubsetcompatible} tell us that instead of starting from $x \in \leafset(T_A[u])$, we could start from the roots of the subtrees discovered in the children. These Lemmas taken together then give us the foundation of the altered \texttt{Filter\_Clusters} algorithm.\\

    \textit{High Level Description.} The algorithm can be visualised as keeping track of two sets of nodes in $T_B$, an $upperBoundary$ and a $lowerBoundary$. For any node $u \in V(T_A)$, the $upperBoundary$ represents the nodes in $T_B$ that are $lca$'s of the clusters associated with children of $u$. These are the nodes from which we iterate upwards to add to the set of candidate incompatible nodes. The $lowerBoundary$ represents the nodes that are roots of subtrees that do not need to be checked again. These are the nodes from which we iterate upwards to remove from the set of candidate incompatible nodes.\\

    \textit{Further Details}. We adopt an approach similar to that in \cite{jansson2018algorithms} for determining whether a given node in $T_B$ is incompatible with a given node in $T_A$. This involves maintaining a property $counter(v)$ for each node $v \in T_B$. If the current node in $T_A$ under consideration is $u$, then we would like $counter(v) = |\leafset(T_B[v]) \cap \leafset(T_A[u])|$. Then if $counter(v) = |\leafset(T_B[v])$, then $\leafset(T_B[v]) \subseteq \leafset(T_A[u])$ and so $\leafset(T_B[v]) \compatible \leafset(T_A[u])$. We also keep track of the nodes that are being found to be compatible, since these will form the new roots of compatible subtrees.

    \begin{algorithm}
        \caption{Filter\_Clusters}
        \label{alg:filterclusters}

        \begin{algorithmic}[1]
            \State \textbf{Input:} Two trees $T_A$, $T_B$ with $\leafset(T_A) = \leafset(T_B) = L$ where every cluster has a known $weight$.

            \State \textbf{Side effects:} Marks any node $u \in V(T_A)$ for deletion iff $w(u) \leq w(x)$ for any $x \in V(T_B)$ with $\leafset(T_A[u]) \not\compatible \leafset(T_B[x])$.

            % TODO: Fix
            \State \textbf{Output:} A dictionary $parentsOfSubtrees$ that
             A linked list $parentsOfSubtrees$ that contains any node $u \in V(T_B)$ iff $u$ is the parent of the root of a maximal proper subtree in $T_B$ that is compatible with any $p_i \in \pi$. There are no duplicates in $parentsOfSubtrees$.

            \State Let $IDS$ be an initially empty Brodal queue for storing nodes from $T_B$.

            \State $c_h :=$ heaviest child of $a$, $r := null$, $lowerBoundary := \{\}$, $upperBoundary := \{\}$, $rootsOfSubtrees := \{\}$

            \ForAll{$c \in children(a)$ in increasing order of heaviness}
                \State $r_c, lowerBoundary', IDS' :=$ \texttt{Filter\_Clusters}$(c, T_B)$

                \State $r := lca^{T_B}(r, r_c)$

                \State $upperBoundary := upperBoundary \cup r_c$

                \State $rootsOfSubtrees := rootsOfSubtrees \cup lowerBoundary'$

                % TODO: Enforce uniqueness of weights
                \State $IDS := IDS \cup IDS'$

                \If{$c \neq c_h$}
                    \State $lowerBoundary := lowerBoundary \cup lowerBoundary'$

                    \State \algorithmicforall\ $x \in lowerBoundary'$, $counter(parent^{T_B}(x)) := 0$
                \EndIf
            \EndFor

            \ForAll{$x \in upperBoundary$}
                \While{$x \not\in IDS$ and $x \neq r$}
                    \State Insert $x$ into $D$
                    \State $x := parent^{T_B}(x)$
                \EndWhile
            \EndFor

            \State $parentsOfLowerBoundary := \{\}$

            \ForAll{$x \in lowerBoundary$}
                \State $counter(parent^{T_B}(x)) := counter(parent^{T_B}(x)) + |\leafset(T_B[x])|$

                \State $parentsOfLowerBoundary := parentsOfLowerBoundary \cup parent^{T_B}(x)$
            \EndFor

            \State $rootsOfSubtrees = lowerBoundary \cup lowerBoundary_h$

            \ForAll{$x \in parentsOfLowerBoundary$}
                \While{$counter(x) = |\leafset(T_B[x])|$ and $x \neq r$}
                    \State $counter(parent^{T_B}(x)) := counter(parent^{T_B}(x)) + |\leafset(T_B[x])|$

                    \State Remove $x$ from $IDS$

                    \State Add $x$ to $rootsOfSubtrees$

                    \State \algorithmicforall\ $x_c \in children(x)$, remove $x_c$ from $rootsOfSubtrees$

                    \State $x := parent^{T_B}(x)$
                \EndWhile
            \EndFor

            \IIEf{$IDS$ is empty}
                {$M := 0$}
                $M :=$ maximum weight of a node in $IDS$

            \IIf{$w(\leafset(T_A[p_i])) \leq M$}
                mark $p_i$ for deletion

            \State \Return $r$, $rootsOfSubtrees$, $IDS$
        \end{algorithmic}
    \end{algorithm}

    \newpage
    \bibliographystyle{plain}
    \bibliography{interim_report}
\end{document}
